## ローグライクゲームを作ってみるその9 マップと視界

### 過去記事一覧

* [その1 タイトル画面](https://qiita.com/pizyumi/items/3526fddd4f18a462e1ae)
* [その2 ダンジョン・プレイヤーの生成と描画](https://qiita.com/pizyumi/items/2562a159f497a608615b)
* [その3 プレイヤーの移動](https://qiita.com/pizyumi/items/07447c9a1a52b0d9a228)
* [その4 ダンジョンのランダム生成]()
* [その5 ダンジョンのサイズ]()

現在のコードについては前回の記事の最後の項を参照してください。

### マップと視界



プレイヤーの視界は部屋にいる時は部屋全体＋周囲1マスとし、部屋にいない時は周囲1マスのみとすることにしましょう。

そして、視界に応じてゲーム画面のフロアやマップの描画を変えることにしましょう。

フロアはプレイヤーの視界内のみを白色で描画することにし、視界外（で以前視界内に入ったことがある部分）は灰色で描画することにします。

### マップの生成

最初に、マップや視界の処理を行うための準備をしましょう。

マップはプレイヤーの状態の一種なので、`Player`クラスのプロパティとして格納することにしましょう。

`Player`クラスに`maps`プロパティを追加します。

このプロパティに全てのフロアのマップを格納することにします。

```js
class Player {
	constructor () {
（省略）
		this.items = [];
		this.maps = [];
	}
（省略）
}
```

また、マップや視界の処理を行うにはプレイヤーが現在いる部屋を監視する必要があります。

フロアの部屋の情報はフロアの作成時に捨ててしまっていましたが、これをフロアを表すオブジェクトの`rooms`プロパティに追加し、後から参照できるようにします。

`create_field`関数を下のように変更します。

```js
function create_field (depth, upstairs, base_seed) {
（省略）
	if (depth === 0) {
（省略）
		return {
			nx: nx,
			ny: ny,
			blocks: blocks,
			rooms: [{
				x1: 1,
				x2: nx - 2,
				y1: 1,
				y2: ny - 2
			}],
			npcs: []
		};
	}
（省略）
	return {
		nx: nx,
		ny: ny,
		blocks: blocks,
		rooms: ers,
		npcs: npcs
	};
}
```

また、下のような3つの位置に関する判定関数を追加します。

* `within_room`関数・・・ある位置がある部屋の中なのか判定する。
* `within_room_surrounding`関数・・・ある位置がある部屋＋周囲1マスの中なのか判定する。
* `within_player_surrounding`関数・・・ある位置がプレイヤーの周囲1マスの中なのか判定する。

```js
function within_room (x, y, room) {
	return x >= room.x1 && x <= room.x2 && y >= room.y1 && y <= room.y2;
}

function within_room_surrounding (x, y, room) {
	return x >= room.x1 - 1 && x <= room.x2 + 1 && y >= room.y1 - 1 && y <= room.y2 + 1;
}

function within_player_surrounding (x, y) {
	return x >= player.x - 1 && x <= player.x + 1 && y >= player.y - 1 && y <= player.y + 1;
}
```

次に、あるフロアのマップを初期化する`init_map`関数を追加します。

第1引数としてマップを初期化するフロアを受け取ります。

フロアのサイズに応じてマップを初期化し、マップを表すオブジェクトを返します。

マップを表すオブジェクトは下のようなプロパティを有します。

* `nx`・・・マップの横方向のサイズ（マップが表すフロアの横方向のサイズと同じ）
* `ny`・・・マップの縦方向のサイズ（マップが表すフロアの縦方向のサイズと同じ）
* `blocks`・・・マップのマス（マップのそれぞれのマスはマップが表すフロアのマスに対応する）
* `room`・・・プレイヤーが現在いる部屋

マップは最初全てのマスが何のマスなのか不明な状態なので、マップの全てのマスの初期値は`M_UNKNOWN`とします。

`M_UNKNOWN`の値は`65535`としました。この値はマスの種類の値と被ってはいけません。

```js
var M_UNKNOWN = 65535;
```

```js
function init_map (field) {
	var nx = field.nx;
	var ny = field.ny;
	var blocks = [];
	for (var i = 0; i < nx; i++) {
		blocks[i] = [];
		for (var j = 0; j < ny; j++) {
			blocks[i][j] = M_UNKNOWN;
		}
	}
	return {
		nx: nx,
		ny: ny,
		blocks: blocks,
		room: null
	};
}
```

その次に、フロアのマップを更新する`update_map`関数を追加します。

プレイヤーが部屋の中にいる場合にはその部屋全体＋周囲1マスのマップを更新し、部屋の中にいない場合にはプレイヤーの周囲1マスのマップを更新します。

```
function update_map (map, field, x, y) {
	for (var i = 0; i < field.rooms.length; i++) {
		var room = field.rooms[i];
		if (within_room(x, y, room)) {
			for (var j = room.x1 - 1; j <= room.x2 + 1; j++) {
				for (var k = room.y1 - 1; k <= room.y2 + 1; k++) {
					map.blocks[j][k] = field.blocks[j][k].base;
				}
			}
			map.room = room;
			return;
		}
	}
	map.blocks[x][y] = field.blocks[x][y].base;
	map.blocks[x - 1][y] = field.blocks[x - 1][y].base;
	map.blocks[x + 1][y] = field.blocks[x + 1][y].base;
	map.blocks[x][y - 1] = field.blocks[x][y - 1].base;
	map.blocks[x][y + 1] = field.blocks[x][y + 1].base;
	map.blocks[x - 1][y - 1] = field.blocks[x - 1][y - 1].base;
	map.blocks[x + 1][y - 1] = field.blocks[x + 1][y - 1].base;
	map.blocks[x - 1][y + 1] = field.blocks[x - 1][y + 1].base;
	map.blocks[x + 1][y + 1] = field.blocks[x + 1][y + 1].base;
	map.room = null;
}
```

マップはフロアの初期化時に初期化されなければなりません。

また、フロアの初期化時とプレイヤーが移動した時に更新されなければなりません。

`init`関数を下のように変更します。

フロアの作成後`init_map`関数と`update_map`関数を呼び出してマップの初期化と更新を行います。

```js
function init () {
（省略）
	fields = [];
	fields[0] = create_field(0, [], seed);
	player = new Player();
	player.maps[0] = init_map(fields[0]);
	update_map(player.maps[0], fields[0], player.x, player.y);
	messages = [{
		text: MSG_INIT,
		type: 'special'
	}];
}
```

2つ目の`keydown`イベントハンドラを下のように変更します。

プレイヤーが移動した時に`update_map`関数を呼び出してマップの更新を行います。

また、下り階段で下の階に降りた時に`init_map`関数（まだマップが作成されていない場合）と`update_map`関数を呼び出してマップの初期化と更新を行います。

```js
	c.on('keydown', function (e) {
（省略）
		if (e.keyCode >= 37 && e.keyCode <= 40) {
（省略）
			if (x !== player.x || y !== player.y) {
（省略）
				if (c) {
（省略）
				}
				else {
					var block = fields[player.depth].blocks[x][y];
					if (B_CAN_STAND[block.base]) {
						player.x = x;
						player.y = y;
						update_map(player.maps[player.depth], fields[player.depth], player.x, player.y);
					}
					else {
（省略）
					}
				}
			}
			else {
				return;
			}
		}
		else if (e.keyCode === 32) {
			var block = fields[player.depth].blocks[player.x][player.y];
			if (block.items && block.items.length > 0) {
（省略）
			}
			else if (block.base === B_DOWNSTAIR) {
				player.depth++;
				if (!fields[player.depth]) {
					fields[player.depth] = create_field(player.depth, [{
						x: player.x,
						y: player.y
					}], seed);
				}
				if (!player.maps[player.depth]) {
					player.maps[player.depth] = init_map(fields[player.depth]);
				}
				update_map(player.maps[player.depth], fields[player.depth], player.x, player.y);
				add_message({
					text: MSG_DOWNSTAIR,
					type: 'normal'
				});
			}
			else {
				return;
			}
		}
		else if (e.keyCode === 88) {
（省略）
		}
		else {
			return;
		}
（省略）
	});
```

### フロアとマップの描画

ゲーム画面の右上端にマップを描画することにします。

また、フロアの描画においてプレイヤーの視界を反映するようにします。

ゲーム画面におけるマップのサイズを定義します。マップのサイズは256ピクセルx256ピクセルとします。

```js
var MAP_WIDTH = 256;
var MAP_HEIGHT = 256;
```

`draw`関数を下のように変更します。

フロアの描画においてはマップで不明となっている部分は描画しません。

また、視界内は白色で描画し、視界外は灰色で描画します。

また、視界外の敵キャラクターの描画しません。

そして、ゲーム画面の右上端にマップを描画します。

マップで不明となっている部分は灰色で描画します。

壁は黒色で描画し、下り階段は黄緑色で描画し、床は青色で描画します。ただし、視界内の床はより薄い青色で描画します。

また、アイテムは黄色で描画し、敵は赤色で描画し、プレイヤーは桃色で描画します。

```js
function draw (con, env) {
（省略）
	var npcs = fields[player.depth].npcs;
	var room = player.maps[player.depth].room;

	for (var i = 0; i < SX; i++) {
		for (var j = 0; j < SY; j++) {
			var block = fields[player.depth].blocks[ox + i][oy + j];
			var mblock = player.maps[player.depth].blocks[ox + i][oy + j];
			if (mblock !== M_UNKNOWN) {
				if ((room !== null && within_room_surrounding(ox + i, oy + j, room)) || (room === null && within_player_surrounding(ox + i, oy + j))) {
					con.fillStyle = 'white';
					con.strokeStyle = 'white';
				}
				else {
					con.fillStyle = 'gray';
					con.strokeStyle = 'gray';
				}

				if (block.base === B_FLOOR) {
					con.beginPath();
					con.arc((i + 0.5) * PX, (j + 0.5) * PY, 1, 0, Math.PI * 2);
					con.closePath();
					con.fill();
				}
				else if (block.base === B_WALL) {
					con.strokeRect(i * PX, j * PY, PX, PY);
					con.beginPath();
					con.moveTo(i * PX, j * PY);
					con.lineTo((i + 1) * PX, (j + 1) * PY);
					con.moveTo((i + 1) * PX, j * PY);
					con.lineTo(i * PX, (j + 1) * PY);
					con.closePath();
					con.stroke();
				}
				else if (block.base === B_DOWNSTAIR) {
					con.drawImage(img, 4 * 32, 5 * 32, 32, 32, i * PX, j * PY, PX, PY);
				}

				if (block.items) {
					for (var k = 0; k < block.items.length; k++) {
						if (block.items[k].type === I_APPLE) {
							con.drawImage(img2, 0 * 32, 0 * 32, 32, 32, i * PX, j * PY, PX, PY);
						}
						else if (block.items[k].cat === I_CAT_POTION) {
							con.drawImage(img2, 7 * 32, 4 * 32, 32, 32, i * PX, j * PY, PX, PY);
						}
					}
				}
			}
		}
	}

	con.textBaseline = 'middle';
	con.textAlign = 'center';
	for (var i = 0; i < npcs.length; i++) {
		if (npcs[i].x >= ox && npcs[i].x < ox + SX && npcs[i].y >= oy && npcs[i].y < oy + SY) {
			if ((room !== null && within_room_surrounding(npcs[i].x, npcs[i].y, room)) || (room === null && within_player_surrounding(npcs[i].x, npcs[i].y))) {
				if (npcs[i].type === E_RAT) {
					con.fillStyle = 'yellow';
					con.font = '24px consolas';
					con.fillText('🐀\uFE0E', (npcs[i].x - ox) * PX + (PX / 2), (npcs[i].y - oy) * PY + (PY / 2));
				}
			}
		}
	}
（省略）
	con.save();
	var nx = player.maps[player.depth].nx;
	var ny = player.maps[player.depth].nx;
	var px = Math.floor(MAP_WIDTH / nx);
	var py = Math.floor(MAP_HEIGHT / ny);
	con.translate(SCREEN_X - nx * px, 0);
	for (var i = 0; i < nx; i++) {
		for (var j = 0; j < ny; j++) {
			var block = fields[player.depth].blocks[i][j];
			var mblock = player.maps[player.depth].blocks[i][j];
			if (mblock === M_UNKNOWN) {
				con.fillStyle = 'gray';
			}
			else if (mblock === B_FLOOR) {
				if (block.items && block.items.length > 0) {
					con.fillStyle = 'yellow';
				}
				else if (room !== null && within_room_surrounding(i, j, room)) {
					con.fillStyle = 'dodgerblue';
				}
				else if (room === null && within_player_surrounding(i, j)) {
					con.fillStyle = 'dodgerblue';
				}
				else {
					con.fillStyle = 'royalblue';
				}
			}
			else if (mblock === B_WALL) {
				con.fillStyle = 'black';
			}
			else if (mblock === B_DOWNSTAIR) {
				con.fillStyle = 'yellowgreen';
			}
			con.fillRect(i * px, j * py, px, py);
		}
	}
	for (var i = 0; i < npcs.length; i++) {
		if ((room !== null && within_room_surrounding(npcs[i].x, npcs[i].y, room)) || (room === null && within_player_surrounding(npcs[i].x, npcs[i].y))) {
			con.fillStyle = 'red';
			con.fillRect(npcs[i].x * px, npcs[i].y * py, px, py);
		}
	}
	con.fillStyle = 'pink';
	con.fillRect(player.x * px, player.y * py, px, py);
	con.restore();
}
```









### 今回はここまで

今回はここまでです。

`game.js`は下のようになりました。

```js
﻿```

次回はマップの描画について考えたいと思います。
