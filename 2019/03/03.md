## ローグライクゲームを作ってみるその3 プレイヤーの移動

元風俗嬢のゆりなです。

風俗嬢をやったら精神がボロボロになってしまったので、ちょっと簡単なゲームでも作ってリフレッシュすることにします。

### 過去記事一覧

* [その1 タイトル画面]()
* [その2 ダンジョン・プレイヤーの生成と描画]()

現在のコードについては前回の記事を参照してください。

### プレイヤーの移動

このゲームは基本的にキーボードを使って操作することにします。

プレイヤーの移動は矢印キーを使って行うことにします。

まず、プレイヤーは全てのマスに移動できる訳ではないのでした。

床のマスには移動できますが、壁のマスには移動できません。

つまり、マスの種類によって移動できるかどうかが決まります。

これを`B_CAN_STAND`という配列で下のように定義することにします。`true`は移動できるマスであることを表し、`false`は移動できないマスであることを表します。

```js
var B_CAN_STAND = [];
B_CAN_STAND[B_FLOOR] = true;
B_CAN_STAND[B_WALL] = false;
```

そして、キー入力の処理を下のように変更します。

```js
	c.on('keydown', function (e) {
		if (!startf) {
			if (e.keyCode === 90) {
				startf = true;

				init();

				draw(con);
			}

			return;
		}

		if (e.keyCode >= 37 && e.keyCode <= 40) {
			var x = player.x;
			var y = player.y;
			if (e.keyCode === 37) {
				if (x === 0) {
					return;
				}
				x--;
			}
			else if (e.keyCode === 38) {
				if (y === 0) {
					return;
				}
				y--;
			}
			else if (e.keyCode === 39) {
				if (x === LX - 1) {
					return;
				}
				x++;
			}
			else if (e.keyCode === 40) {
				if (y === LY - 1) {
					return;
				}
				y++;
			}

			if (x !== player.x || y !== player.y) {
				var b = field[x][y];
				if (B_CAN_STAND[b.base]) {
					player.x = x;
					player.y = y;

					draw(con);
				}
			}
		}
	});
```

矢印キーが押された時の処理が追加されました。

矢印キーの種類によってプレイヤーの新しい位置が決まり、その位置のマスの種類が移動できるものである場合には移動し（プレイヤーの位置を更新し）、再描画を行います。

[](https://codepen.io/pizyumi/pen/ExYOVwj)

<p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="pizyumi" data-slug-hash="ExYOVwj" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="roguelike-3-1">
  <span>See the Pen <a href="https://codepen.io/pizyumi/pen/ExYOVwj/">
  roguelike-3-1</a> by pizyumi (<a href="https://codepen.io/pizyumi">@pizyumi</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

### 斜め移動

ローグライクゲームはやっぱり斜め移動もできないとですよね。

斜め移動を実装しましょう。

斜め移動は`Shift`キーを押しながら矢印キーを押すことで行うこととします。

実装においては少なくとも以下の2点を満たす必要があるかと思います。

* `Shift`キーを押している時のみしか斜め移動できない（`Shift`キーを押していないのに斜め移動できてはならない）。
* `Shift`キーを押している時には斜め移動しか出来ない（`Shift`キーを押している時には上下左右の移動はできてはならない）。

このようにすることにより、誤操作が起きにくくなります。

このような斜め移動の実装方法は幾つかあると思いますが、私は下のような実装方法が好きです。

`keyl`、`keyu`、`keyr`、`keyd`という変数を用意し、矢印キーが押されているかどうかを常に監視するようにします。

そして、`Shift`キーが押されている場合にはこれらの変数の値をもとに移動を行うべきかを判断します。

```js
	var keyl = false;
	var keyu = false;
	var keyr = false;
	var keyd = false;

	var c = $('body');
	c.on('keydown', function (e) {
		if (e.keyCode === 37) {
			keyl = true;
		}
		else if (e.keyCode === 38) {
			keyu = true;
		}
		else if (e.keyCode === 39) {
			keyr = true;
		}
		else if (e.keyCode === 40) {
			keyd = true;
		}
		else {
			keyl = false;
			keyu = false;
			keyr = false;
			keyd = false;
		}
	});
	c.on('keyup', function (e) {
		if (e.keyCode === 37) {
			keyl = false;
		}
		else if (e.keyCode === 38) {
			keyu = false;
		}
		else if (e.keyCode === 39) {
			keyr = false;
		}
		else if (e.keyCode === 40) {
			keyd = false;
		}
	});
	c.on('keydown', function (e) {
		if (!startf) {
（省略）
		}

		if (e.keyCode >= 37 && e.keyCode <= 40) {
			var x = player.x;
			var y = player.y;
			if (e.shiftKey) {
				if (keyl && keyu) {
					if (x === 0 || y === 0) {
						return;
					}
					x--;
					y--;
				}
				else if (keyr && keyu) {
					if (x === LX - 1 || y === 0) {
						return;
					}
					x++;
					y--;
				}
				else if (keyl && keyd) {
					if (x === 0 || y === LY - 1) {
						return;
					}
					x--;
					y++;
				}
				else if (keyr && keyd) {
					if (x === LX - 1 || y === LY - 1) {
						return;
					}
					x++;
					y++;
				}
				else {
					return;
				}
			}
			else {
				if (e.keyCode === 37) {
					if (x === 0) {
						return;
					}
					x--;
				}
				else if (e.keyCode === 38) {
					if (y === 0) {
						return;
					}
					y--;
				}
				else if (e.keyCode === 39) {
					if (x === LX - 1) {
						return;
					}
					x++;
				}
				else if (e.keyCode === 40) {
					if (y === LY - 1) {
						return;
					}
					y++;
				}
			}

			if (x !== player.x || y !== player.y) {
				var b = field[x][y];
				if (B_CAN_STAND[b.base]) {
					player.x = x;
					player.y = y;

					draw(con);
				}
			}
		}
	});
```








### ダンジョン生成

ローグライクゲームのポイントって何点かあると思うのですが、その1つはダンジョン生成だと思います。

ランダム生成なのは勿論ですが、適度に探索しやすく、それでいて探索しがいのあるダンジョンが理想だと思います。

でも、そんなダンジョンを最初から生成するのって難しいですよね。

それより先にとりあえず動くものを作ってしまいたいです。

そこで今回はダンジョン生成については何も考えません。

空っぽの部屋を1つ作るだけにします。

今回は描画処理の実装を頑張ります。

---

まずダンジョンの（暫定的な）仕様を決めましょう。

* 2D
* 正方形のマスを縦横に敷き詰める
* 正方形のマスは縦横32ピクセル
* 床と壁から成り、床はプレイヤーが歩けるが、壁は歩けない
* 1つのフロアの大きさは25x25

とりあえずこんな感じにしましょう。

フロアの大きさを25x25にしたのは、これだとフロアの大きさは25*32=800ピクセルとなり、ちょうどゲーム画面に収まるからです。

ゲーム画面に収まらないとフロアの一部しか描画できないということになり面倒なのです。

勿論最終的にはもっと広いフロアにも対応可能にしていきたいですが。

という訳で、コードを書いていきましょう。

```
var LX = 25;
var LY = 25;
var PX = 32;
var PY = 32;
```

フロアの大きさと1マスのピクセル数です。

```
var B_FLOOR = 0;
var B_WALL = 1;
```

マスの種類を数値で表すことにします。

床は`0`、壁は`1`とします。

```
function create_field () {
	var f = [];
	for (var i = 0; i < LX; i++) {
		f[i] = [];
		for (var j = 0; j < LY; j++) {
			if ((i === 0 || j === 0) || (i === LX -1 || j === LY - 1)) {
				f[i][j] = {
					base: B_WALL
				};
			}
			else {
				f[i][j] = {
					base: B_FLOOR
				};
			}
		}
	}

	return f;
}
```

フロアを作成する関数です。

端だけ壁にし、それ以外は床にします。

```
var field = null;

function init () {
	field = create_field();
}
```

`init`関数を実装します。

フロアを作成し、`field`変数に格納します。

### ダンジョンの描画

次にダンジョンの描画を行います。

`draw`関数に下のようなコードを追加します。

```
	for (var i = 0; i < LX; i++) {
		for (var j = 0; j < LY; j++) {
			if (field[i][j].base === B_FLOOR) {
				con.fillStyle = 'white';
				con.beginPath();
				con.arc((i + 0.5) * PX, (j + 0.5) * PY, 1, 0, Math.PI * 2);
				con.closePath();
				con.fill();
			}
			else if (field[i][j].base === B_WALL) {
				con.strokeStyle = 'white';
				con.strokeRect(i * PX, j * PY, PX, PY);
				con.beginPath();
				con.moveTo(i * PX, j * PY);
				con.lineTo((i + 1) * PX, (j + 1) * PY);
				con.moveTo((i + 1) * PX, j * PY);
				con.lineTo(i * PX, (j + 1) * PY);
				con.closePath();
				con.stroke();
			}
		}
	}
```

マスが床の場合には白い点をマスの中心に描画します。

また、マスが壁の場合は四角に囲まれた×を描画します。

これにより描画されるダンジョンは下のようになります。

![](p01.png)

### プレイヤーの生成

次にプレイヤーを生成します。

`init`関数を下のように変更します。

```
var player = null;

function init () {
	field = create_field();
	player = {
		x: 12, 
		y: 17
	};
}
```

プレイヤーを作成し、`player`変数に格納します。

プレイヤーは以下のプロパティを持ちます。

* `x`・・・プレイヤーのダンジョンにおける横方向の位置
* `y`・・・プレイヤーのダンジョンにおける縦方向の位置

プレイヤーのダンジョンにおける最初の位置は`(12, 7)`ということにしました。

### プレイヤーの描画

次にプレイヤーの描画を行います。

`draw`関数に下のようなコードを追加します。

```
	con.textBaseline = 'middle';
	con.textAlign = 'center';
	con.fillStyle = 'red';
	con.fillText('🚶', player.x * PX + (PX / 2), player.y * PY + (PY / 2));
```

プレイヤーがいるマスに人の絵文字を赤色で描画します。

これにより描画されるダンジョンは下のようになります。

![](p02.png)

### 今回はここまで

今回はここまでです。

`game.js`は下のようになりました。

```
var TITLE = 'シンプルローグライク';

var SCREEN_X = 1600;
var SCREEN_Y = 800;

var LX = 25;
var LY = 25;
var PX = 32;
var PY = 32;

var B_FLOOR = 0;
var B_WALL = 1;

var startf = false;

var field = null;
var player = null;

$(function(){
	var canvas = document.getElementById('game');
	var con = canvas.getContext('2d');

	var c = $('body');
	c.on('keydown', function (e) {
		if (!startf) {
			if (e.keyCode === 90) {
				startf = true;
	
				init();
	
				draw(con);
			}
			
			return;
		}
	});

	draw(con);
});

function init () {
	field = create_field();
	player = {
		x: 12, 
		y: 17
	};
}

function create_field () {
	var f = [];
	for (var i = 0; i < LX; i++) {
		f[i] = [];
		for (var j = 0; j < LY; j++) {
			if ((i === 0 || j === 0) || (i === LX -1 || j === LY - 1)) {
				f[i][j] = {
					base: B_WALL
				};
			}
			else {
				f[i][j] = {
					base: B_FLOOR
				};
			}
		}
	}

	return f;
}

function draw (con) {
	con.fillStyle = 'black';
	con.fillRect(0, 0, SCREEN_X, SCREEN_Y);

	if (!startf) {
		con.textBaseline = 'alphabetic';
		con.textAlign = 'center';
		con.fillStyle = 'white';

		con.font = "48px consolas";
		con.fillText(TITLE, SCREEN_X / 2, SCREEN_Y / 4);

		con.font = "32px consolas";
		con.fillText('> はじめる', SCREEN_X / 2, SCREEN_Y / 4 * 3);	

		return;
	}

	for (var i = 0; i < LX; i++) {
		for (var j = 0; j < LY; j++) {
			if (field[i][j].base === B_FLOOR) {
				con.fillStyle = 'white';
				con.beginPath();
				con.arc((i + 0.5) * PX, (j + 0.5) * PY, 1, 0, Math.PI * 2);
				con.closePath();
				con.fill();
			}
			else if (field[i][j].base === B_WALL) {
				con.strokeStyle = 'white';
				con.strokeRect(i * PX, j * PY, PX, PY);
				con.beginPath();
				con.moveTo(i * PX, j * PY);
				con.lineTo((i + 1) * PX, (j + 1) * PY);
				con.moveTo((i + 1) * PX, j * PY);
				con.lineTo(i * PX, (j + 1) * PY);
				con.closePath();
				con.stroke();
			}
		}
	}

	con.textBaseline = 'middle';
	con.textAlign = 'center';
	con.fillStyle = 'red';
	con.fillText('🚶', player.x * PX + (PX / 2), player.y * PY + (PY / 2));
}
```

次回はプレイヤーの移動を行いたいと思います。
